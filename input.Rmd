---
output: 
  html_document:
  toc: true
  theme: united
params: 
    set_title: "My Title!"
title: "`r params$set_title`"
date: "`r format(Sys.time(), '%d %B, %Y')`"
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(rms)
library(Hmisc)
library(pec)
library(prodlim)
library(reshape2)
```

**Bootstrap = 3**

#### (1) Full Model 
```{r fullmodel development, include = FALSE}
# Model development 
# imputing missing data
completed <- d
imputed <- impute.transcan(imp, imputation=1, data=d, list.out=TRUE, pr=FALSE, check=FALSE) 
completed[names(imputed)] <- imputed
dd <<- datadist(completed); options(datadist ="dd")

fullmodel <- fit.mult.impute(fm, fitter = cph, xtrans = imp, data = d, x=TRUE, y=TRUE, surv=TRUE, time.inc=5)
```

```{r fullmodel plots}
# estimation curve for variable
ggplot(Predict(fullmodel), sepdiscrete ='vertical', nlevels=4, vnames ='names')
# estimation result
fullmodel
# figure 1 - importance of each variable
# anova(fullmodel)
plot(anova(fullmodel, tol=1e-13))
```

**Model Validation**
```{r validation, warning = FALSE}
# For full model
FunDiscrimination <- function (model, bootstrap) {
  set.seed (10)
  v <- validate (model, B=bootstrap)
  print(v)
  Dxy = v[rownames(v)=="Dxy", colnames(v)=="index.corrected"]
  c.stat <- Dxy/2+0.5
  print(paste("C-statistic =", round(c.stat, 4)))
  c.stat
}
c.stat <- FunDiscrimination(fullmodel, 3)
```

**Model Calibration**
  
```{r calibration, warning = FALSE}
# if we want to predict 10-year risk, change times=5 to times=10.
completed$pred <- 1 - predictSurvProb(fullmodel, completed, times=5)
# event after 5 years is setted to censored status? If so, run following code 
# completed$event[completed$event == 1 & completed$years > 5] <- 0
# table(completed$event)
# if above annotation code is executed, c-statistics for each group is slightly larger.
# predict 10 group's risk probabilities
# cut data.frame into 10 group
FUN.deciles_mean_pred <- function(data) {
  data <- data[order(data$pred),]
  data$group <- cut2(data$pred, g=10)
  data$event <- as.numeric(data$event)
  levels(data$group) <- c(1:10)
  observed <- rep(NA, 10)
  for (i in 1:10) {
    km <- survfit(Surv(years, event)~1, data=data[data$group==i, ])
    survest <- stepfun(km$time, c(1, km$surv))
    observed[i] <- 1-survest(5) # risk at 5-years
  }
  mean_pred <- tapply(data$pred, data$group, mean)
  data.frame(observed, pred = mean_pred, Deciles=1:10)
}

# multiple plot function
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL){
  library(grid)
  plots <- c(list(...), plotlist)
  numPlots = length(plots)
  if (is.null(layout)) {
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }
  if (numPlots==1) {
    print(plots[[1]])
    
  } else {
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    for (i in 1:numPlots) {
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

# predict survival probability and observed probability for overall
dat <-FUN.deciles_mean_pred(completed)
dat.melt <- melt(dat, id.vars = 'Deciles', variable.name = 'Group', value.name = 'Risk')
plot_all <- function(dat.melt){
  ggplot(dat.melt, aes(x = Deciles, y = Risk*100, color = Group)) + geom_point(size = 4) +  xlab("Tenth of predicted risk") + ylab("5 year risk (%)") + theme(axis.title.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=12)) + scale_x_continuous(breaks = NULL) + scale_y_continuous(breaks=seq(0, 100, 10)) + scale_color_manual(values = c("observed" = 'skyblue1','pred' = 'darkblue'), labels=c("observed" = 'Observed','pred' = 'Predicted')) + theme(legend.position="bottom", legend.title=element_blank(), legend.text = element_text(size = 12, face = "bold"))
}
plot_all(dat.melt)
```

```{r calibration_sex, warning = FALSE, eval = FALSE}
# predict survival probability and observed probability for male group
dat <- FUN.deciles_mean_pred(completed[completed$female==F,])
dat.melt <- melt(dat, id.vars = 'Deciles', variable.name = 'Group', value.name = 'Risk')
plot_male <- function(dat.melt){
  p1 <- ggplot(dat.melt, aes(x = Deciles, y = Risk*100, color = Group)) + geom_point(size = 4) +  xlab("Tenth of predicted risk") + ylab("5 year risk (%)") + theme(axis.title.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=12)) + scale_x_continuous(breaks = NULL) + scale_y_continuous(breaks=seq(0, 100, 10)) + scale_color_manual(values = c("observed" = 'skyblue1','pred' = 'darkblue'), labels=c("observed" = 'Observed','pred' = 'Predicted')) + theme(legend.position="bottom", legend.title=element_blank(), legend.text = element_text(size = 12, face = "bold")) + ggtitle("Male") 
}
p1 <- plot_male(dat.melt)

# predict survival probability and observed probability for female group
dat <- FUN.deciles_mean_pred(completed[completed$female==T,])
dat.melt <- melt(dat, id.vars = 'Deciles', variable.name = 'Group', value.name = 'Risk')
plot_female<-function(dat.melt){
  p2 <- ggplot(dat.melt, aes(x = Deciles, y = Risk*100, color = Group)) + geom_point(size = 4) +  xlab("Tenth of predicted risk") + ylab("5 year risk (%)") + theme(axis.title.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=12)) + scale_x_continuous(breaks = NULL) + scale_y_continuous(breaks=seq(0, 100, 10)) + scale_color_manual(values = c("observed" = 'pink','pred' = 'darkred'), labels=c("observed" = 'Observed','pred' = 'Predicted')) + theme(legend.position="bottom", legend.title=element_blank(), legend.text = element_text(size = 12, face = "bold")) + ggtitle("Female") 
  p2 <- ggplot(dat.melt, aes(x = Deciles, y = Risk*100, color = Group)) + geom_point(size = 4) +  xlab("Tenth of predicted risk") + ylab("5 year risk (%)") + theme(axis.title.x = element_text(size=14), axis.title.y = element_text(size=14), axis.text.y = element_text(size=12)) + scale_x_continuous(breaks = NULL) + scale_y_continuous(breaks=seq(0, 100, 10)) + scale_color_manual(values = c("observed" = 'pink','pred' = 'darkred'), labels=c("observed" = 'Observed','pred' = 'Predicted')) + theme(legend.position="bottom", legend.title=element_blank(), legend.text = element_text(size = 12, face = "bold")) + ggtitle("Female") 
}
p2 <- plot_female(dat.melt)
multiplot(p1, p2, cols = 1)
```

#### (2) Age interaction 
**Age interaction**
``` {r age interaction, eval = TRUE}
z <- predict(fullmodel, type="terms")
z.age <- z[, "age"]
z.other <- subset(z, select=-age)
f.ia <- cph(fullmodel$y ~ z.age * z.other)
anova(f.ia )
```

```{r, ref.label='validation', warning = FALSE, eval = FALSE}
```

```{r, ref.label='calibration', warning = FALSE, eval = FALSE}
```

#### (3) Simplified model 
**Model approximation** 
  Set at 90% of R^2^

```{r modelapprox, warning = FALSE, message = FALSE}
FUN.approx <- function(mod, completedata) {
  lp <- predict(mod)
  a <- ols(as.formula(paste0("lp ~ ", paste(labels(terms(fm)), collapse = "+"))), sigma=1, data=completedata)
  s <- fastbw(a, aic=1000000)
  betas <- s$Coefficients
  X <- model.matrix(fm, data=completedata)
  ap <- X %*% t(betas)
  m <- ncol(ap) - 1
  fullchisq <- mod$stats[3]
  r2 <- frac <- numeric(m)
  for(i in 1:m) {
    lpa <- ap[,i]
    r2[i] <- cor(lpa, lp)^2
    fapprox <- cph(Surv(years, event) ~ lpa, data=completedata, x=TRUE, y=TRUE)
    frac[i] <- fapprox$stats[3]/fullchisq
  }
  list(r2=c(1, r2), frac=c(1, frac), predictor=row.names(s[[1]]))
}
# figure 2 - r^2 approximation
r <- FUN.approx(fullmodel, completed)
plot(r$r2, r$frac, type="b", ylab="Fraction", xlab=expression(r^2))
tab <- cbind(number=(length(r[[2]])):1, frac=c(r[[1]]), predictor=r[[3]])
tab
# write.csv(tab, "table_r2.csv")

# Validation for the approximate model
Cindex_approx <- function(number_bootstrap){
  c_index <- NULL
  for(i in 1:number_bootstrap){
    # Bootstrap sampling
    boostrap_sample <- completed[sample(1:nrow(completed), nrow(completed), replace = TRUE), ]
    boostrap_fullmodel <- cph(fm, data=boostrap_sample, x=TRUE, y=TRUE, surv=TRUE, time.inc=5)
    r <- FUN.approx(boostrap_fullmodel, boostrap_sample)
    
    # Select variables that makes up 90% of R2
    cutoff <- max(which(r[[1]]>0.9))
    term_remove <- paste0(r[[3]][1:cutoff], collapse = '|')
    fm_terms <- terms(fm)
    term_remove_index <- grep(term_remove, attr(fm_terms, 'term.labels'))
    fm_approx <- drop.terms(fm_terms, term_remove_index, keep.response = TRUE)
    
  # Fit the approximate model
  approx_model <- cph(fm_approx, data=boostrap_sample, x=TRUE, y=TRUE, surv=TRUE, time.inc=5)
    
    # Calculate the C-index
    completed$pred <- predict(approx_model, newdata=completed)
    score_result <- data.frame(pred=completed$pred, years=completed$years, event=completed$event)
    c_index <- c(c_index, c(survConcordance(Surv(years, event) ~ pred, score_result)$concordance))
  }
  fm_terms <<- fm_terms
	fm_approx <<- fm_approx
	term_remove <<- term_remove
	approx_model <<- approx_model
	print(c_index)
	c_index
}
c_index <- Cindex_approx(3)
```
Mean c-index = `r round(mean(c_index), 4)`

Approx model formula is: 
```{r}
formula(fm_approx)
approx_model

# save approx model
# model <- fit.mult.impute(fm_approx, fitter = cph, xtrans = imp, data = d, x=TRUE, y=TRUE, surv=TRUE, time.inc=5)
```

```{r, ref.label='calibration', warning = FALSE}
```


